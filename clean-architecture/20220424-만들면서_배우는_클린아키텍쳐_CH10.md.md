#CleanArchitecture

- 책에 대한 간단한 내용과   
*개인적인 생각*   
Q 궁금한 점에 대한 정리.  

---
# 10. 아키텍처 경계 강제하기

- 아키텍처 내의 경계를 강제하는 방법

## 경계와 의존성
- 아키텍처의 경계를 강제한다 ? -> 의존성이 올바른 방향으로 향하도록 강제하는 것을 의미
- 계층 경계를 넘는 의존성은 항상 안쪽 방향을 향해야한다.


## 접근 제한자
- package-private : 자바 패키지를 통해 클래스들을 응집적인 '모듈'로 만들어준다.
	- 모듈 내 클래스들은 서로 접근 가능하지만 패키지 바깥에서 접근 X
	- 모듈의 진입점을 골라 public으로 만들어준다.
	- 그렇다면 의존성 규칙을 위반할 위험이 줄어든다.
	- 의존성 주입 매커니즘은 일반적으로 리플레션을 이용해 클래스를 인스턴스로 만들어 package-private여도 여전히 인스턴스를 만들 수 있다.

## 컴파일 후 체크 
- 클래스에 public 제한사 사용시 의존성 방향이 잘못되어도 컴파일 타임에 확인할 수 없다.
- 컴파일 후 체크는 컴파일된 후 런타임에 체크를 한다.
- 지속적인 통합 빌드환경에서 자동화된 테스트 과정에서 가장 잘 동작한다.
	- 자바용 도구 ArchUnit
수 있는 api를 제공.
- *이런 저런 도구 쓸바에 처음부터 설계를 잘하는게 낫겠다*

## 빌드 아티팩트
- 빌드 아티팩트는 빌드 프로세스의 결과물 
	- ex) jar 파일 등
- 기존의 코드들은 모두 모놀리식 빌드 아티팩트(monolithic build artifact)
- 모듈의 빌드 스크립트에서는 아키텍쳐에서 허용하는 의존성만 지정한다.
- 클래스들이 클래스 패스에 존재하지 않으면 바로 컴파일 에러가 발생해 잘못된 의존성을 만들 수 없다.
- 모듈을 세분화할 수록 모듈간 의존성을 더 잘 제어할 수 있게된다.
- 하지만 작게 분리할 수록 모듈간 매핑을 많이 수행해야한다.
- 여러 개의 빌드 모듈은 각 모듈을 격리한 채로 변경할 수 있게 해준다.

## 유지보수 가능한 소프트웨어를 만드는데 어떤 도움이 될까 ?
- 아키텍쳐를 잘 유지하기 위해선 의존성이 올바른 방향을 가리키고 있는지 지속적으로 확인이 필요
- 가능하면 package-private을 통해 패키지 바깥에서 접근하면 안되는 것에 대한 의존성을 갖지 못하게 한다
- package-private이 안되면 archunit같은 컴파일 후 체크 도구를 사용
- 아키텍쳐가 안정적이면 아키텍처 요소들을 독립적인 빌드 모듈로 추출해 의존성을 분명하게 제어한다.
- 모든 방식을 함께 조합해 사용해도 된다.