- 책에 대한 간단한 내용과   
*개인적인 생각*   
Q 궁금한 점에 대한 정리.  

---
# 4. 유스케이스 구현하기
- 헥사고날 아키텍쳐는 DDD에 적합하기 때문에, `도메인 -> 바깥 방향`으로 구현해 나간다.

## 유스케이스의 순서
- `입력 받기 -> 비지니스 규칙 검증 -> 모델 상태 조작 -> 출력 반환`  
  *인커밍 어댑터 -> 유스케이스 -> 도메인*

  <br>

- 유스케이스는 입력 유효성 검증으로 오염되면 안되고 오로지 `도메인 로직만` 신경 써야 한다.  
- But. 유스케이스는 `비즈니스 규칙`을 검증할 책임이 있다.  

<br>

### 입력 유효성 검증 vs 비지니스 규칙 검증
- `입력 유효성 검증`은 유스케이스 클래스 책임은 아니지만 `application 계층의 책임`이다.   
	- 어댑터에서 입력 유효성 검증을 한다면 도메인을 사용하는 모든 어댑터에서 검증이 제대로 이루어졌는지 신뢰할 수 없다.  
- 그러면 입력 유효성 검증은 어디서 ?   
	- `입력 모델(input model)`에서 다룬다 (~Command)  
		- *~ReqDto와 비슷한 것 같다*  
		- 입력 모델 내 `생성자`에서 검증  
			- 일반적으로 Java 표준 Bean Validation API를 사용한다.  
	**- 유스케이스마다 다른 입력 모델을 써야한다.**  

- 비즈니스 규칙 검증
	- 1) `도메인 엔티티` 안에 넣는다 (Domain)
	- 2) `유스케이스 코드에서` 도메인을 사용하기 전에 검증한다 (Service)
		- 도메인 모델을 로드해야한다면 도메인 엔티티 내 비즈니스 규칙을 구현한다.

## 풍부한 도메인 모엘 vs 빈약한 도메인 모델 
### 풍부한 도메인 모델
- 엔티티에서 가능한 많은 도메인 로직이 구현됨
- 많은 비지니스가 유스케이스 대신 엔티티에 위치한다

### 빈약한 도메인 모델
- 엔티티는 필드, getter, setter를 갖고 비지니스 로직이 존재하지 않는다.
- 도메인 로직은 유스케이스 클래스에 구현되어 있다


## 유스케이스마다 다른 출력 모델
- 입력과 마찬가지로 출력도 각 `유스케이스에 맞게 구체적`인 것이 좋다
- 데이터를 얼마나 반환할지 의심스럽다면 `가능한 적게 반환`하자.
- 왜냐하면 유스케이스간 `같은 출력 모델을 공유`해도 `유스케이스간 강결합`되기 때문
	- 공유 모델은 장기적으로 보면 점점 거친다.
	- 단일 책임 원칙을 지켜야 결합을 제거할 수 있다.

## 읽기 전용 유스케이스 
- 모델의 상태를 변경하지 않고 데이터를 가져만 오는 쿼리
- 쿼리를 위한 인커밍 전용 포트를 만들고 `쿼리 서비스(query service)`를 따로 둔다.
- 이런 방식은 CQS(Command-Query Separation) or `CQRS(Command-Query Responsibility Segregation)`의 개념과 잘 맞는다.

## 유지보수 가능한 소프트웨어
- 입출력 모델을 가급적 독립적이게 모델링하면 side effect를 피할 수 있다.
- 각 유스케이스마다 별도의 모델을 만들고 이 모델과 엔티티를 매핑해야한다
	- ? 매핑의 개념이 정확히 어떤 의미인지 토론했으나 코드를 직접 봐야 알 것같다
- 꼼꼼한 입력 유효성 검증, 유스케이스별 입출력 모델은 `지속 가능한 코드`를 만드는데 도움이 된다. 

# 5. 웹 어댑터 구현하기 
- 어댑터와 유스케이스 사이에 포트가 들어서있고 포트와 유스케이스는 의존성 역전이 적용되어 있다.
	- **포트를 따로 둬야하는 이유 ?** 
	- 애플리케이션 코어가 `외부와 통신할 수 있는 곳에 대한 명세`가 포트이므로 포트를 적절한 곳에 위치 시키면 외부와 어떤 통신이 일어나는지 알 수 있다  

<br>

- 웹 소켓과 같이 실시간으로 데이터를 주고 받는 경우 ?
	- 컨트롤러 <web\> -> 포트 <port.in> <- 서비스 <service\>
	- 웹소켓 컨트롤러 <web\>  -> 포트 <port.out> <- 서비스 <service\>
		- 웹 어댑터는 인커밍 어댑터면서 아웃고잉 어댑터가 된다
		- 한 어댑터가 동시에 두가지 역할을 하게된다.

## 웹 어댑터의 책임
- HTTP와 관련된 것은 어플리케이션 계층에 영향을 주면 안된다.
- 입력 객체의 변환까지 유효성 검증을 해야한다. 


### 컨트롤러 나누기 
- 컨트롤러는 한 개 이상이어도 된다.
- 넓은 서비스가 아닌 좁은 서비스가 좋은 것처럼, 너무 적고 큰 것보다 너무 많고 작은게 낫다
- 클래스마다 코드는 적을수록 좋다
- 모든 연산을 `단일 컨트롤러`에 넣을 수록 `데이터 구조를 재활용` 하게 된다
- 그 데이터 구조는 모든 데이터를 담는 큰 통의 역할을 한다
- 그렇게 되면 불필요한 데이터가 너무 많고 그렇기 때문에 일부는 null을 허용해야한다
- 유효성 검증또한 애매해진다.
- 그러므로 컨트롤러 또한 유스케이스와 맞춰 최대한 작게 만들어라 
- 그리고 전용 모델 클래스를 사용하고
- 적절하게 한 패키지로 묶는다면
- 실수로 패키지 외부에서 재사용될 일이 적어진다.

## 유지보수 가능한 소프트웨어
- 웹 어댑터는 HTTP 요청과 유스케이스 사용을 위한 변환 작업을, 애플리케이션 계층은 HTTP와 관련된 작업을 하지 않는다.
	- 웹 어댑터를 다른 어댑터로 교체하기가 쉬워진다.
- 웹 컨트롤러는 `모델을 공유하지 않는` 여러 작은 클래스를 만드는 것이 좋다
- 더 파악하기 쉽고, 테스트 짜기 쉽고, 동시작업을 지원하며, 유지보수가 쉽다.