# 6.영속성 어댑터 구현하기
영속성 계층에 모두 의존하게 되면 DB 주도 설계가 되고 만다. 이를 지양하기 위해 의존성을 역전해 영속성 계층을 애플리케이션 계층의 플러그인으로 만들어보자.
## 의존성 역전
- service 에서 호출 -> port.out(interface) <- persistence 에서 구현 
	- 이 영속성 어댑터는 주도되는 어댑터 / 아웃고잉 어댑터, 호출될 뿐 직접 호출은 하지 않는다.

- 포트는 사실상 서비스와 영속성 코드 사이의 간접적인 계층
- 이렇게 분리하는 경우 서비스와 무관하게 영속성 어댑터를 수정 가능하다.
- 의존성은 어플리케이션 코어에서 어댑터로 향햐게 된다


## 영속성 어댑터의 책임
1. `포트 인터페이스`를 통해 입력을 받는다
2. `영속성 어댑터`는 입력을 DB포맷으로 매핑한다
	- 맥락에 따라 입력 모델(command)를 JPA로 매핑하는 것이 너무 비싼 일이 될 수 있어 매핑하지 않는 전략도 존재한다.
3. 입력을 DB로 보낸다
4. DB 출력을 Application 포맷으로 매핑
5. 출력을 반환
- 영속성 어댑터의 입력 모델이 어플리케이션 코어에 존재해서 영속성 어댑터 내부를 변경하는 게 코어에 영향을 미치지 않는다. 
- 출력 모델 또한 애플리케이션 코어에 위치해야한다.
- 입출력 모델이 영속성 어댑터가 아닌 애플리케이션 코어에 있는 것을 제외하면 전동적인 영속성 계층의 책임과 크게 다르지 않다.


## 포트 인터페이스 나누기 
- 문제는 포트 인터페이스를 어떻게 나눌 것인지 ? 
- 일반적으로는 모든 DB 연산을 하나의 레포지토리에 때려넣는다.
	- 이럴 경우 여기에 의존하는 서비스들은 너무 넓은 포트 인터페이스에 의존성을 갖게된다.

### 인터페이스 분리 원칙 
- Interface Segregation Principle, ISP
- 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리해야한다.
- 각 서비스는 실제로 필요한 메소드에만 의존하게된다.
	- 테스트에서 어떤 메서드를 모킹할지 고민할 필요 X
	- 대부분 포트당 하나의 메서드만 있을 것이기 때문
- 매우 좁은 포트를 만드는 것 = 플러그 앤드 플레이 (Plug-and-play) 

## 영속성 어댑터 나누기 
- 어댑터 또한 port 인터페이스와 같이 꼭 한개라는 법은 없다.
- DDD라 치면 애그리거트 하다랑, 또는 영속성 연산이 필요한 도메인 클래스 당 하나의 영속성 어댑터를 구현하는 방식을 취할 수 있다.
	- 이런 경우 각 영속성 기능을 이용하는 도메인 경계를 따라 자동으로 나눠진다.
	- 도메인은 영속성 포트만 알면 되지 정의된 명세를 어떤 클래스가 충족 시키는지 관심 X

### 바운디드 컨테스트 
- 경계
- 경계간 접근을 하려면 인커밍 포트를 통해 접근해야한다.


### 매핑하지 않기 전략
- JPA객체와 도메인 객체를 분리 
- JPA로 인해 도메인 모델을 타협할 수 밖에 없는 경우가 생긴다
	- ex) 성능상 JPA의 ManyToOne을 쓰는 것이 좋지만 도메인 비지니스 는 반대가 더 적절할 때
- 영속성과 타협 없이 풍부한 도메인 모델을 생성하고 싶으면 도메인 모델과 영속성 모델을 매핑하는게 좋다.(라고 써있는데 하지 말라는게 결론 아닌가..?)

## DB 트랜잭션은?
### 트랜잭션의 경계는 어디에 ?
- 트랜잭션은 하나의 특정한 유스케이스에 대해 일어나는 모든 쓰기 작업에 걸쳐있어야 한다
- 그래야 하나라도 실패하면 롤백이 가능
- 영속성 어댑터를 호출하는 서비스에 위임해야한다
- AOP로도 가능



