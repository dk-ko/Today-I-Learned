- 책에 대한 간단한 내용과  
*개인적인 생각*  
**토론한 내용**  
Q 궁금한 점에 대한 정리  
---

# 1. 계층형 아키텍처의 문제는 무엇일까 ?
- 계층을 이용한 사고 방식은 지금까지 모범사례로 여겨짐
	- 웹 -> 도메인 -> 영속성
- 계층을 잘 이해하고 구성하면 `도메인 로직이 독립적`이게 작성할 수 있다
- 하지만 계층형 아키텍쳐는 `나쁜 습관`이 스며들기 쉽다 

### 이유 1. 계층형 아키텍처는 데이터베이스 주도 설계를 유도함
- 우리는 상태(state)가 아닌 행동(behavior)를 중심으로 모델링한다
	- *하지만 데이터베이스, 객체 등은 행동이 아닌 상태로 관리된다.*
- 왜 DB 주도 설계를 하게 될까 ?
	- 계층형 아키텍쳐의 의존성을 따라가다보면 그게 자연스럽다
- ORM이 문제다 
	- 도메인 -> 영속성 구조 
	- DB Schema 와 1:1 매핑된 엔티티는 영속성에 속하게 되고, 도메인 계층은 해당 엔티티를 그대로 사용하면서 강결합 상태가 된다
	- *즉 DB Schema에 의존적인 설계가 될 수 밖에 없다*
### 이유 2. 아키텍쳐를 강제하는 규칙이 적다.
- 규칙은 단 하나 특정 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다
- 이걸 지키며 지름길을 가기 위해, 상위 컴포넌트를 내리던지 하위 컴포넌트를 올리던지 조작을 하게되며
- 이를 통해 계층이 점점 비대해진다. 특히 영속성 계층은 모든 것을 할 수 있어 유력하다.
	- *JPA의 OSIV가 Default인 것을 봐도 JPA 진영에서는 영속성 계층이 비대해지는 것에 대해 인식을 못하고 (?) 개발을 한 것 같다. JPA의 OSIV처럼 트랜잭션이 UI 영역 까지 간다면 영속성 계층에 대한 강결합 현상이 일어날 것 같다.* 

그래서 나빠진 계층형 아키텍처는 아래와 같은 단점을 가진다
### 1. 테스트하기 어려워짐
- 계층을 뛰어 넘으면서 도메인 로직을 웹 계층에도 도메인 계층에도 영속성 계층에서 구현하게 된다.
	- 결과적으로 도메인 로직이 흩어진다
		- *예를 들면 우리 팀 레거시 코드의 경우 도메인 로직이 컨트롤러와 서비스, 레포지토리에 흩어져있어 이 부분이 공감이 많이 갔다* 
- 이렇게 되면 테스트 설정이 복잡해서 테스트를 작성안하는 쪽으로 가게된다
- 왜냐하면 테스트를 작성하는 것보다 종속성을 모두 이해하고 Mock을 만드는데 더 많은 시간이 걸리기 때문  
	- *Mock 테스트의 단점은 구현 기능에 대해 자세히 알고 있어야 한다는 것. 그리고 구현에 밀접하게 의존하기 때문에 테스트가 깨지기 쉽다. 힘들게 의존성을 파악해 테스트를 작성해두더라도 덕지덕지 붙은 의존성 때문에 테스트 내용이 파악하기 힘들고, 그로 인해 이후 로직을 변경하더라도 테스트를 변경하지 않는다면 바로 깨지는 테스트가 될 것이다.*

### 2. 유스케이스를 숨긴다
- 이 책에서는 유스케이스는 아주 작은 단위의 서비스를 뜻한다 
- 계층형 아키텍처는 도메인 서비스의 `너비`에 대한 규칙을 강제하지 않는다. 
	- 넓은 서비스는 코드 상에서 특정 유스케이스를 찾는 걸 힘들게 한다.
	- *이미 비대해진 도메인 로직이 흩어진 상태에서는 새로운 기능을 추가할 때 적당한 위치를 찾기는 어렵다.*
- 고도로 특화된 좁은 도메인 서비스가 유스케이스 하나씩 담당한다면 이런 작업들이 수월해진 것이다 (작가 의견)
	- *이상적으로 보이긴하지만.. 서비스의 규모가 커질수록 객체의 크기가 커지는데 현실적으로 얼마나 작은 유스케이스를 만들 수 있을지는 아직은 잘 모르겠다*

### 3. 동시 작업이 어려워진다.
- DB 중심의 서비스 설계는 `영속성 계층 -> 도메인 계층 -> 웹 계층` 순으로 개발이 이뤄진다. 
- 계층형 아키텍쳐는 동시 작업에 도움이 되지 않는다. 
- 특히 코드에 넓은 서비스가 있으면 서로 다른 기능을 동시에 작업하기 어렵다
	- 충돌 겁나남 ^^..


## 결론
- 계층형 아키텍쳐는 강제성이 적어서 나쁜 구조로 가기 쉽다.
	- 계층형 아키텍쳐를 제대로 작성한다면 꼭 나쁜건 아니다
- 다른 아키텍쳐를 택하더라도 계층형의 단점을 숙지하고 지양하는 것이 좋다.


# 2. 의존성 역전하기 
- 핵심은 `단일 책임 원칙 (Single Responsibility Principle)`, `의존성 역전(Dependency Inversion Principle)`

## 단일 책임 원칙 
- 기존의 번역은 "하나의 컴포넌트는 오로지 한 가지의 일만 해야 하고, 그것을 올바르게 수행해야 한다". 
- 하지만 `한가지 일` 보다 `변경` 이 좀 더 적절하다
- "컴포넌트를 `변경`하는 이유는 오직 하나뿐이어야 한다"
	- **이 부분에 대해 의견이 분분했는데, 대부분 기존의 의미가 좀 더 와닿는다고 말을 했다.
	컴포넌트는 메소드로 이해하고 메소드가 한번에 하나의 일을 해야한다는 의견. 그리고 약간의 말장난인 것 같다는 의견도 나왔다.**
	- *내 의견은 `변경`이 좀 더 적절해 보인다고 생각한다. Object나 DB의 경우 상태(Status)를 갖는다. 상태는 행동을 표현할 수 없고 값을 적절히 변경함으로써 정적인 객체 등으로 동적인 상태를 표현한다. 따라서 한가지의 일 보다는 값을 변경한다는 의미가 좀 더 적절한 것이 아닐까 싶다.*
	- *여기서 좀 더 나아가 Immutable Object를 지향한다면 값을 변경하는 어떤 동작을 취한 경우 해당 객체에서 값을 변경한 새로운 객체를 반환하도록 코드를 작성할 것이다. 그렇다면 해당 객체는 그 메소드를 사용해 생성되는 그 상황 한가지가 컴포넌트를 변경하는 상황이 될 것이다. 이 것이 좀 더 명확한 것 같기도 하다.*
- 또한 `변경할 이유`가 오로지 한가지라면 컴포넌트는 딱 한가지 일만 하게 되고, 변경할 이유가 오직 한가지이며, 따라서 소프트웨어의 다른 부분을 변경하더라도 이 컴포넌트에 대해 전혀 신경 쓸 필요가 없다.  
	*- 즉 Side Effect 가 줄어들 것으로 예상된다*
- 변경할 이유는 컴포넌트 간의 의존성을 통해 쉽게 전파 된다.  
- 변경할 이유가 많이 쌓인 후에는 한 컴포넌트를 바꾸는 것이 다른 컴포넌트가 실패하는 원인이 될 수 있다. 

## 의존성 역전 원칙 
- 기존의 구조라면 영속성 계층에 대해 도메인 계층이 의존하고 있어, 영속성 계층이 변경될 때 도메인 객체도 변경하게 된다. (영속성 <- 도메인)  
- 하지만 난 바꾸기 시른딩  
	- 그럼 의존성을 제거해야한다 	 
- 어떻게 제거할 수 있을까 ?  
	- 도메인 코드와 영속성 코드 간의 의존성을 역전 시켜 영속성 코드가 도메인에 의존하고 도메인의 `변경할 이유`의 갯수를 줄인다. (영속성 -> 도메인)
	- 도메인 계층의 서비스는 도메인 엔티티, 리포지포리 interface에 의존하고, 영속성 계층의 리포지토리 객체를 리포지토리 Interface, 와 영속성의 엔티티에 접근한다
		- Q. 여기서 궁금한 것은 Interface로 분리한 것을 어떻게 찾아가서 (?) 접근하냐 (?)에 대한 의문이 들었다. Spring이라면 Bean으로 지정해 구체화된 객체를 지정해줄 수도 있을 것 같은데, 순수 자바로 이루어진 코드라면 어떻게 작성하고 어떻게 동작하는 걸까.
- 즉 엔티티를 DB 접근용 / 비지니스용을 분리하고 리포지토리 인터페이스를 도메인 쪽에 두어 영속성에서 도메인을 의존하도록 `의존성 방향을 역전했다.`

## 클린 아키텍쳐
- 도메인이 독립적이기 위해서는 도메인 코드가 `바깥으로 향하는 어떤 의존성`도 없어야한다.
- 즉 `모든 의존성`은 `코어 (도메인)`을 향한다.
	- *코어는 DB가 아니다. DB 또한 외부의 의존성이다.*
- 코어가 모든 의존성에 자유로워 지면 그때 도메인 코드를 자유롭게 모델링할 수 있다. 

## 육각형 아키텍처(헥사고날 아키텍처)
- 육각형은 사실 아무 의미가 없다. `포트와 어댑터(ports-and-adapters) 아키텍처`가 좀 더 알맞은 명명이다. 
- 헥사고날 아키텍쳐 또한 모든 의존성은 코어를 향한다.
- 포트를 통해 코어에 접근이 가능하다
- `주도하는 어댑터(driving adapter)`는 포트가 코어에 있는 유스케이스 클래스 등에 구현되고, `주도되는 어댑터(driven adapter)`에는 포트가 어댑터에 의해 구현되고 코어에 의해 호출될 것.
	- *주도하는 어댑터의 예시는 front client -> serber api controller, 주도되는 어댑터는 B 서비스가 A서비스에 의존할 때 호출하는 케이스가 되지 않을까 생각했다.*
	- **결국 의존 방향에 따라 헥사고날 아키텍쳐는 주도하는 어댑터 -> 유스케이스 -> 주도되는 어댑터와 같이 한방향으로 흐른다.**
	- **대부분의 헥사고날 아키텍처는 이런 모양을 띈다.**

## 그래서 유지가능한 소프트웨어는 어떻게 만들까 ?
- 중요한건 `의존성을 역전`해 `도메인` 코드를 `의존에서 자유롭게` 짤 수 있어야 하고, 코드를 `변경할 이유`의 수를 줄일수록 `유지보수성`이 좋아질 것이다. 


## 그리고.. 
*삼색펜 기법을 처음 사용해 보았는데 우선 한페이지에 한가지 빨간색을 강제하는 것만으로 주제의 흐름이 보이는 것 같아서 좋았다. 또한 다른 사람들과 겹치는 의견, 다른 의견등을 보며 잘못 이해한 부분을 제대로 파악하고, 잘 이해한 부분은 설명하며 좀 더 깊게 이해할 수 있어서 재밌었다.*